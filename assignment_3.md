# Assignment 3 -- Assembly

*due on 6 June 2018*

The goal of this assignment is to implement the parts remaining to obtain an executable.

For simplicity we are targeting x86, not x86_64.
This can be achieved on a 64 bit installation by passing `-m32` to GCC when compiling your generated assembler code.
For this, the [GCC multilib package](https://packages.debian.org/buster/gcc-multilib) needs to be installed.

## Task 1

- Implement code generation.

The task is to convert your TAC to assembly code which can be compiled with the [GNU Assembler](https://en.wikipedia.org/wiki/GNU_Assembler).

To achieve this you should investigate how simple code snippets (if statement, while loop, ...) are translated by GCC.

You do not have to perform register allocation, or other fancy optimisations for this.
Each variable should simply be located on the stack.
Read it into a CPU register when needed for an operation and store the result in the corresponding location on the stack afterwards.
Yet, pay special attention to floating point and integer handling.

Use [cdecl calling convention](https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl).
It is crucial to correctly implement the calling convention, otherwise you will corrupt your stack during function calls and returns.

*Note:* You might want to disable optimisations, security features, and other information irrelevant for this task when investigating the code generated by the compiler.
Yet, do *not* disable the use of frame pointers via `-fomit-frame-pointer`.

*Note 2:* Use `long` and `double` in C as they correspond to mC's `int` and `float`.

*Example 1:* Take the following C snippet:

```c
long add(long a, long b)
{
	long c = a + b;
	return c;
}
```

Using the following compiler invocation,

    $ gcc -m32 -S -O0 -fno-stack-protector -fno-asynchronous-unwind-tables add.c

yields the following GNU assembler code (`add.s`):

```asm
	.file	"add.c"
	.text
	.globl	add
	.type	add, @function
add:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	8(%ebp), %edx
	movl	12(%ebp), %eax
	addl	%edx, %eax
	movl	%eax, -4(%ebp)
	movl	-4(%ebp), %eax
	leave
	ret
	.size	add, .-add
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
```

It still contains a bit of unnecessary meta data, but the relevant part (function `foo`) should be understandable.

The corresponding object file can be generated by passing `-c` to GCC followed by the input file -- like with C source files.

    $ gcc -m32 -c add.s
    $ ls
    add.c add.o add.s

*Example 2:* If certain things are still a bit unclear to you, you can instruct the compiler to provide more verbose output.
Take the C snippet from the previous example and try the following commands (see [Matters Computational](https://www.jjj.de/fxt/fxtbook.pdf) page 3):

    $ gcc -m32 -S -fno-stack-protector -fno-asynchronous-unwind-tables -fno-dwarf2-cfi-asm -fverbose-asm -g -O0 add.c
    $ as --32 -alhnd add.s > add.lst

The newly created file `add.lst` now contains not only the assembly code generated by the compiler, but also displays the corresponding input source code:

```asm
   1                            .file   "add.c"
   2                    # GNU C11 (Ubuntu 5.4.0-6ubuntu1~16.04.9) version 5.4.0 20160609 (x86_64-linux-gnu)
                        [...]
  35
  36                            .text
  37                    .Ltext0:
  38                            .globl  add
  40                    add:
  41                    .LFB0:
  42                            .file 1 "add.c"
   1:add.c         **** long add(long a, long b)
   2:add.c         **** {
  43                            .loc 1 2 0
  44 0000 55                    pushl   %ebp    #
  45                    .LCFI0:
  46 0001 89E5                  movl    %esp, %ebp      #,
  47                    .LCFI1:
  48 0003 83EC10                subl    $16, %esp       #,
   3:add.c         ****         long c = a + b;
  49                            .loc 1 3 0
  50 0006 8B5508                movl    8(%ebp), %edx   # a, tmp93
  51 0009 8B450C                movl    12(%ebp), %eax  # b, tmp94
  52 000c 01D0                  addl    %edx, %eax      # tmp93, tmp92
  53 000e 8945FC                movl    %eax, -4(%ebp)  # tmp92, c
   4:add.c         ****         return c;
  54                            .loc 1 4 0
  55 0011 8B45FC                movl    -4(%ebp), %eax  # c, D.1487
   5:add.c         **** }
  56                            .loc 1 5 0
  57 0014 C9                    leave
  58                    .LCFI2:
  59 0015 C3                    ret
  60                    .LFE0:
 104                    .Letext0:
```

## Task 2

- Implement back-end compiler invocation.

Now that we obtained assembly code we can convert it to an executable by running it through an assembler and linker.
For this we'll simply pass it to GCC.
This also allows us to attach the built-in functions, just pass the C source file to the compiler call.

Double check whether the built-in functions provided to your back-end compiler use the same calling convention.

You should now have a working compiler which can convert valid mC input programs to executables.

## Task 3

Polish the commandline parameter handling of your main compiler executable.
At least the following flags must be provided:

- `-h` / `--help`    to display usage information
- `-v` / `--version` to display version information
- `-o` / `--output`  to specify the resulting executable

## Task 4

Extend your integration test runner to also execute the generated binary.
Pass the content of the corresponding `.stdin` file to the binary and compare its output with the corresponding `.stdout` file.
Matching output indicates success.

Either use a temporary directory (`mktemp`) or the build directory to store the integration test executables.

## Submission

Follow the steps stated in the first assignment, using the following command to build the archive and the link below.

    $ git archive --prefix=team_XX_assignment_3/ --format=zip HEAD > team_XX_assignment_3.zip

:email: [send email](mailto:alexander.hirsch@uibk.ac.at?subject=703602%20-%20Assignment%203)
