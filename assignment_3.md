# Assignment 3 -- Assembly

*due on 6 June 2018*

The goal of this assignment is to implement the parts remaining to obtain an executable.

For simplicity we are targeting x86, not x86_64.
This can be achieved on a 64 bit installation by passing `-m32` to GCC when compiling your generated assembler code.
For this, the [GCC multilib package](https://packages.debian.org/buster/gcc-multilib) needs to be installed.

## Task 1

- Implement code generation.

The task is to convert your TAC to assembly code which can be compiled with the [GNU Assembler](https://en.wikipedia.org/wiki/GNU_Assembler).

To achieve this you should investigate how simple code snippets (if statement, while loop, ...) are translated by GCC.

You do not have to perform register allocation, or other fancy optimisations for this.
Each variable should simply be located on the stack.
Read it into a CPU register when needed for an operation and store the result in the corresponding location on the stack afterwards.
Yet, pay special attention to floating point and integer handling.

Use [cdecl calling convention](https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl).
It is crucial to correctly implement the calling convention, otherwise you will corrupt your stack during function calls and returns.

*Note:* You might want to disable optimisations, security features, and other information irrelevant for this task when investigating the code generated by the compiler.
Yet, do *not* disable the use of frame pointers via `-fomit-frame-pointer`.

*Example:* Take the following C snippet:

```c
long add(long a, long b)
{
	long c = a + b;
	return c;
}
```

Using the following compiler invocation,

    $ gcc -m32 -S -O0 -fno-stack-protector -fno-asynchronous-unwind-tables add.c

yields the following GNU assembler code (`add.s`):

```asm
	.file	"add.c"
	.text
	.globl	add
	.type	add, @function
add:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	8(%ebp), %edx
	movl	12(%ebp), %eax
	addl	%edx, %eax
	movl	%eax, -4(%ebp)
	movl	-4(%ebp), %eax
	leave
	ret
	.size	add, .-add
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
```

It still contains a bit of unnecessary meta data, but the relevant part (function `foo`) should be understandable.

The corresponding object file can be generated by passing `-c` to GCC followed by the input file -- like with C source files.

    $ gcc -m32 -c add.s
    $ ls
    add.c add.o add.s

## Task 2

- Implement back-end compiler invocation.

Now that we obtained assembly code we can convert it to an executable by running it through an assembler and linker.
For this we'll simply pass it to GCC.
This also allows us to attach the built-in functions, just pass the C source file to the compiler call.

Double check whether the built-in functions provided to your back-end compiler use the same calling convention.

You should now have a working compiler which can convert valid mC input programs to executables.

## Task 3

Polish the commandline parameter handling of your main compiler executable.
At least the following flags must be provided:

- `-h` / `--help`    to display usage information
- `-v` / `--version` to display version information
- `-o` / `--output`  to specify the resulting executable

## Task 4

Extend your integration test runner to also execute the generated binary.
Pass the content of the corresponding `.stdin` file to the binary and compare its output with the corresponding `.stdout` file.
Matching output indicates success.

Either use a temporary directory (`mktemp`) or the build directory to store the integration test executables.

## Submission

Follow the steps stated in the first assignment, using the following command to build the archive and the link below.

    $ git archive --prefix=team_XX_assignment_3/ --format=zip HEAD > team_XX_assignment_3.zip

:email: [send email](mailto:alexander.hirsch@uibk.ac.at?subject=703602%20-%20Assignment%203)
